# 교착상태(Deadlock)

**교착상태 필요조건**

- 상호배타
  - 한 프로세스가 자원을 사용하고 있다면, 다른 프로세스는 이 자원을 사용할 수 없다.
- 보유 및 대기
  -  한 프로세스가 자원을 가지고 있는 상태에서 대기한다.
- 비선점
  - 한 프로세스가 자원을 수행하는 중에는 다른 프로세스가 중간에 끼어들 수 없다.
- 환형대기
  - 프로세스가 요구하는 자원의 방향이 원형을 이룬다. (대기가 꼬리에 꼬리를 문 상황**)**



**교착상태 처리**

- 교착상태 방지
  - 교착상태 필요조건 네 가지 중 최소 한 가지를 만족시키지 않도록 하는 것
    - 식사하는 철학자 문제
- 교착상태 회피
  - 운영체제가 자원을 나누어 주는 과정에 대한 문제를 고려하는 방식
  - 교착상태를 발생하지 않도록 알고리즘을 적용하는 방법
    - 자원할당 그래프 알고리즘 & 은행원 알고리즘
- 교착상태 검출 및 복구
  - 교착상태를 허용하되, 교착상태가 발생하면 복구하는 방식
- 교착상태 무시
  - 교착상태가 발생하는 것에 준비를 하지 않는다.

+++



## 교착상태 회피

> 교착상태 = 자원 요청에 대한 잘못된 승인 (은행원 알고리즘)
>
> ex) 돈(자원)을 빌려주기만 하는 은행에서 고객(프로세스)들이 돈을 적절히 나눠주면
>
> 이자(수익)이 있는 반면, 잘못 나눠주면 부도(deadlock)가 난다.

![11](교착상태(Deadlock).assets/11.jpg)



**예제**

- 12개의 magnetic tape 및 3개의 process
- 안전한 할당 (Safe allocation)

| Process | Max needs | Current needs |
| :-----: | :-------: | :-----------: |
|   P0    |    10     |       5       |
|   P1    |     4     |       2       |
|   P2    |     9     |       2       |

> Max needs : 프로세스가 생성되어 끝날 때 까지 제일 많이 필요로 하는 tape의 개수
>
> Current needs : 현재 필요한 tape의 개수

Current needs 대로 나누어 주면 교착상태가 발생하지 않고, tape가 3개가 남는다.

`정말 안전한 할당인가?`

- P0는 현재 5개의 tape를 할당 받았지만, 이후 5개를 더 필요로 한다. (P0가 끝나는 조건)
  - 남은 tape는 3개 = P0는 실행을 끝내지 못한다.
- P1은 2개를 더 필요로 한다.
  - 남은 tape는 3개 = P1은 실행을 끝낼 수 있다. -> 실행이 끝나면 Max needs(4개의 tape)를 전부 다 OS에 반환한다. -> 남은 tape 5개

- 남은 tape 5개를 P0에 모두 주면 P0의 Max needs를 충족시키고, 실행이 끝나면 10개의 tape을 전부 다 OS에 반환한다. -> 남은 tape 10개
- 마지막으로 P2도 실행이 끝날 수 있다.

=> **안전한 할당(안전상태)**이다. 



**그렇다면 P2가 자원 하나를 더 요청한다면 어떻게 될까?**

| Process | Max needs | Current needs |
| ------- | --------- | ------------- |
| P0      | 10        | 5             |
| P1      | 4         | 2             |
| P2      | 9         | 3             |

P1에게 tape 2개를 더 줘서 자원을 모두 돌려받는다 하더라도, 남은 tape은 4개 이기 때문에 P0, P2의 Max needs를 충족할 수 없다.

결국 불안전 상태가 된다.

> 불안전상태 : 모든 프로세스를 사용할 수 없는 상태. 불안전상태는 교착상태이기 위한 필요조건

즉, 운영체제는 P2가 자원 하나를 더 요청했을 때 교착 상태에 빠질 가능성이 있다고 판단하기 때문에 빌려주지 않는다.(회피) 그러므로, P2에 자원 하나를 더 주지 않는 선택을 한다.

`단점`

- 사용자 프로세스가 고정되어야 한다.
- 최대 자원 요구량을 미리 알아야 한다.

```
은행원 알고리즘은 해당 프로세스가 시작할 때 프로세스가 가지고 있어야 할 자원의 최대 개수를 미리 알아야 하기 때문에 실제 돌아가는 프로그램에 적용하기가 상당히 어렵다.
현재 채택하고 있는 방식이 아니다.
```

+++

## 교착상태 검출 및 복구

`어떻게?`

처음부터 OS에 교착상태가 발생하지 않도록 자원 할당 방식을 처리하는 것이 아니라,

프로세스가 필요한대로 자원을 모두 나누어 주도록 한다.

실제로는 교착상태가 잘 일어나지 않는다.



### 교착상태 검출

만약, 교착상태가 발생한다면,

OS의 프로세스 관리 부서에서 하나의 프로그램이 컴퓨터를 주기적으로 검사해야한다.

>  주기적 : 너무 자주 하면 CPU, 메모리 부담이 크다.



### 교착상태 복구

- 프로세스 일부 강제 종료
- 자원 선점하여 일부 프로세스에게 할당



`단점`

교착상태가 발생하기 이전의 상황을 기억해야 하므로 이에 따른 추가적인 메모리가 필요로 함.

비용 문제

+++

## 교착상태 무시

`왜 무시를 할까?`

교착상태는 교착상태 필요조건 네 가지를 모두 만족해야 일어나고, **네 가지 모두 만족을 해도 교착상태가 일어날 가능성이 있는 것**이기 때문

개인 PC = 재부팅하면 된다.



+++

## How does Windows deal with deadlock?

> 우리가 사용하는 Windows에서 데드락을 어떻게 해결할까?



**Mark Phaedrus**

> Microsoft의 Software 엔지니어

```
 윈도우에는 런타임에 교착 상태를 점검하도록 특별히 설계된 기능이 내장되어 있지 않다.
(드라이버는 대개 교착 상태가 발생하기 때문에 드라이버 개발자들이 교착 상태를 진단할 수 있도록 설계된 도구를 가지고 있지만,
최종 사용자 기계에서 실행되는 것은 아니다.)

 그 기본적인 이유는 교착상태를 신뢰성 있게 감지하는 것이 중단 문제를 해결하는 것과 같다는 것이다.
예를들어, Windows(윈도우)에서는 현재 두 개의 스레드가 서로 교착 상태에 빠져 있다고 판단할 수 있다.
즉, 스레드 A가 파일 1에서 독점 쓰기 권한을 가지고 있고 파일 2에서 대기하고 있으며, 스레드 B가 파일 2에서 독점 쓰기 권한을 가지고 있으며 파일 1에서 대기하고 있다는 것이다.

 그러나 많은 프로그램들은 자체적인 데드락 방지 보호 기능을 가지고 있으며, 심지어 다른 이유로 인해 교착상태에서 벗어나게 되지 않을 수도 있는 프로그램들도 있다. 스레드 A 또는 스레드 B 중 하나가 언제든지 잠금을 해제할 수 있거나, 스레드 C가 나타나 스레드 B를 강제로 종료하거나, 스레드 A를 포함하는 프로세스가 다른 이유로 종료될 수 있다.
 
 윈도우는 사실 무제한의 교착상태인지 아니면 단순히 일시적인 교착상태인지 알 길이 없다. 그리고 그동안 Windows가 표준 교착 상태 해결 전략을 사용했다면 즉, 리소스 중 하나에 대한 하나의 스레드의 잠금을 해제하거나 단순히 스레드 중 하나를 종료하는 등 사용자들이 보는 것은 애초에 현실적이지 않았을 수도 있는 교착 상태를 해결하기 위해 데이터 손실을 포함한 임의의 행동일 가능성이 높다.

 일반적인 Windows 소프트웨어에서 교착상태는 드물기 때문에 "프로그램 중 하나를 포기하거나 사용자가 작업을 종료하거나 컴퓨터를 다시 시작할 때까지 두 스레드가 교착상태에 빠지도록 내버려두어라"보다 더 정교한 전략을 사용하여 대처하는 것이 Windows에게는 역효과를 가져올 정도로 드물다.
 
 																											- 번역 도움 : 파파고
```



## Driver Verifier : Deadlock Detection

> 드라이버는 대개 교착 상태가 발생하기 때문에 드라이버 개발자들이 교착 상태를 진단할 수 있도록 설계된 도구를 가지고 있지만,
> 최종 사용자 기계에서 실행되는 것은 아니다.

### Driver Verifier 란?

```
 Microsoft Windows에는 몇 가지 문제 해결 도구가 있다. 그 중 교착 상태를 검출할 수 있는 Driver Verifier 도구가 있다.
이 드라이버를 활성화하면 Windows 커널 모드 드라이버를 모니터링하여 시스템을 손상 시키거나 중단시킬 수 있는 불법 행위와 호출을 식별할 수 있다.
이 드라이버는 일반 사용자(개인 PC)에서는 거의 사용하지 않는다.
만약 사용할 경우 시스템 복원 지점을 만드는 것이 좋다.

 드라이버 개발자들이 편안하고, 수정 비용이 적게 들게 끔 개발 초기단계에 이 드라이버를 이용할 수 있다.
```



### Driver Verifier 사용 방법 (따라하지 말 것)

1. Driver Verifier 시작

   시작 메뉴 열고, verifier 입력 후 실행

2. `Create custom settings(for code developers)`옵션 선택

   - 교착 상태 감지
   - 보안 검사

3. ![driver](교착상태(Deadlock).assets/driver.JPG)

PC의 드라이버 목록이 나오고 원하는 작업 하면 됨.

4. Driver Verifier 중지하는 방법
   - 24시간 동안 실행 가능하나, 권하지 않음
   - 다시 실행하고 `Delete Existing Settings` 누르면 된다.



+++

- 자원 할당 그래프 알고리즘?
  - https://m.blog.naver.com/PostView.nhn?blogId=wndrlf2003&logNo=220018724037&proxyReferer=https:%2F%2Fwww.google.com%2F

- Mark Phaedrus님의 의견
  - https://www.quora.com/How-does-Windows-deal-with-deadlocks
- 드라이브 개발자들의 교착상태 검출
  - https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/deadlock-detection